gcc -Wall -Wextra main.c -o main  -lncurses
 ./main

make
    ./build/server
    make clean

rm -rf build server
    gcc -Wall -Wextra -g -Iinclude \
    src/server.c src/map.c src/process_input.c src/process_drone.c \
    -lncurses -o server
        ./server

assignment1/
    │
    ├── src/
    │   ├── server.c
    │   ├── map.c
    │   ├── process_input.c
    │   ├── process_drone.c
    │   ├── obstacles.c     (più avanti)
    │   ├── targets.c       (più avanti)
    │   ├── config.c        (più avanti)
    │   └── world.c         (fisica - più avanti)
    │
    ├── include/
    │   ├── map.h
    │   ├── process_input.h
    │   ├── process_drone.h
    │   ├── obstacles.h
    │   ├── targets.h
    │   ├── config.h
    │   └── world.h
    │
    ├── bin/
    │   ├── parameters.cnf
    │   ├── log.txt
    │   └── runtime dumps (qualunque file generi)
    │
    ├── build/
    │   ├── obj/     (file .o)
    │   └── bin/     (eseguibili finali)
    │
    └── Makefile



CONFIG - MAP - SERVER
    map.c       → modulo grafico (GUI) -> si occupa solo della finestra
    map.h       → interfaccia pubblica del modulo grafico

    config.c    → parser del file config -> legge parametri
    config.h    → interfaccia del parser (struttura Parametri + load_config)

    server.c    → gestisce tutti i processi + blackboard

FASE 1
    /project
    │
    ├── server.c
    ├── map.c
    ├── map.h
    ├── process_input.c
    ├── process_input.h
    ├── process_drone.c
    ├── process_drone.h
    └── Makefile  


move_drone(filgio) - pipe_drone(pipe padre-figlio) - select(server)
    Il tuo programma server fa tre cose:
    1. crea 2 pipe:
        - pipe_input (per ricevere messaggi dal processo input),
        - pipe_drone (per ricevere messaggi dal processo drone);
    2. fa 2 fork():
        - uno crea il processo input (legge tasti e manda dx/dy);
        - l’altro crea il processo drone (manda un tick ogni 20ms);
    3. il processo padre (server) entra in un loop con:
        - select()
        - e poi legge dai due file descriptor (pipe_input[0], pipe_drone[0]).

    move: manda messaggio 'click' ogni 20ms a server "Ei server aggiorna fisica"
    pipe: 'tubatura' che collega drone(che scrive) - server(che legge)
    server: legge pipe_input(tasto premuto (“I”, dx dy)) e drone(tick (“D” ogni 20ms))

    QUINDI
        move_drone = genera tick 'D'
        pipe_drone = trasporta il tick al server
        select() = notifica al server che è arrivato il tick
        server = calcola fisica ad ogni tick