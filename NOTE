gcc -Wall -Wextra main.c -o main  -lncurses
 ./main

ARP-Project/
│── src/
│   ├── server_test.c
│   ├── ncurses_test.c
│   ├── watchdog_test.c
│   └── pipes_test.c
│── include/
│── build/
│── Makefile
│── params.txt


CHIEDERE:
#include <ncurses.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#ifndef MAP_H
#define MAP_H
//------------------------------------------------------------------------STRUCTS

// Window
typedef struct {
    WINDOW *win;
    int width, height;
    int startx, starty;
} Screen;

// Drone 
typedef struct{
	char ch;
	int x,y;
	double M, F, K;
    double vx, vy;
} Drone;

// Gamestate
typedef struct {
    Drone drone;
    int obstacle_x, obstacle_y;
    int target_x, target_y;
    int score;
} GameState;

//------------------------------------------------------------------------FUNCTIONS

WINDOW *create_newwin(int height, int width, int starty, int startx);
void destroy_win(WINDOW *local_win);

void init_screen(Screen *s);
void refresh_screen(Screen *s, GameState *g);
void init_game(GameState *g, Screen *s);

void input_move(GameState *g, int ch, Screen *s);
void update_move(GameState *g, double dt, Screen *s);
void render(Screen *s, GameState *g);


WINDOW *create_newwin(int height, int width, int starty, int startx) {
    WINDOW *local_win = newwin(height, width, starty, startx);
    box(local_win, 0, 0);
    wrefresh(local_win);
    return local_win;
}

void destroy_win(WINDOW *local_win){
    if(!local_win) return;
    werase(local_win);
    wrefresh(local_win);
    delwin(local_win);
}

void init_screen(Screen*s){
    s-> starty = 1;
    s-> startx = 1;
    s-> height = LINES-2;
    s-> width = COLS-2;
    s-> win = create_newwin(s->height, s->width, s->starty, s->startx);
}

void refresh_screen(Screen *s, GameState *g) {
    s->height = LINES - 2;
    s->width  = COLS  - 2;

    destroy_win(s->win);
    s->win = create_newwin(s->height, s->width, s->starty, s->startx);

    mvprintw(0, 0, "Press keys (w e r s d f x c v), F2 = quit");
    clrtoeol();   
    refresh();

    if (g->drone.x >= s->width-1){
        g->drone.x = s->width-2;
    }
    if (g->drone.y >= s->height-1){
        g->drone.y = s->height-2;
    }
}



void init_game(GameState *g, Screen *s){
    memset(g, 0, sizeof(GameState));
    g-> drone.ch = '+';
    g-> drone.x = s->width/2;
    g-> drone.y = s->height/2;
    g-> drone.M = 1;
    g-> drone.F = 1;
    g-> drone.K = 1;
    g-> drone.vx = 0;
    g-> drone.vy = 0;

    g-> obstacle_x = 5;
    g-> obstacle_y = 3;

    g-> target_x = s-> width-6;
    g-> target_y = s-> height-4;

    g-> score = 0;
}

void input_move(GameState *g, int ch, Screen *s){
    switch (ch) {
        case 'w': // up-left
            if (g->drone.y > 1 && g->drone.x > 1) {
                g->drone.y--;
                g->drone.x--;
            }
            break;
        case 'e': // up
            if (g->drone.y > 1) {
                    g->drone.y--;
                }
            break;
        case 'r': // up-right
                if (g->drone.y > 1) {
                g->drone.y--;
                g->drone.x++;
            }
            break;
        case 's': // left
            if (g->drone.x > 1) {
                g->drone.x--;
            }
            break;
        case 'd': // brake
            break;
        case 'f': // right
            if (g->drone.x< s->width-2) {
                    g->drone.x++;
            }
            break;           
        case 'x': // down-left
            if (g->drone.y < s->height-2 && g->drone.x > 1) {
                g->drone.y++;
                g->drone.x--;
            }
            break;
        case 'c': // down
            if (g->drone.y < s->height-2) {
                g->drone.y++;
            }
            break;
        case 'v': // down-right
            if (g->drone.y < s->height-2 && g->drone.x < s->width-2) {
                g->drone.y++;
                g->drone.x++;
            }
            break;
        default:
            break;
    }

    // forze ?
}

void update_move(GameState *g, double dt, Screen *s) {
    if (g->drone.x == g->target_x && g->drone.y == g->target_y) {
        g->score++;

        g->target_x = 3 + (rand() % (s->width - 6));
        g->target_y = 3 + (rand() % (s->height - 6));
    }
    //------>Eulero
}

void render(Screen *s, GameState *g){
    werase(s->win);
    box(s->win, 0, 0);

    // print
    mvwprintw(s->win, 0, 2, "Score: %d", g->score);
    mvwprintw(s->win, 0, s->width-20, "F2 = quit");

    // obstacles and targets
    if (g->obstacle_y >= 1 && g->obstacle_y < s->height-1 &&
        g->obstacle_x >= 1 && g->obstacle_x < s->width-1)
        mvwaddch(s->win, g->obstacle_y, g->obstacle_x, 'o');

    if (g->target_y >= 1 && g->target_y < s->height-1 &&
        g->target_x >= 1 && g->target_x < s->width-1)
        mvwaddch(s->win, g->target_y, g->target_x, '1');

    // drone
    if (g->drone.y >= 1 && g->drone.y < s->height-1 &&
        g->drone.x >= 1 && g->drone.x < s->width-1)
        mvwaddch(s->win, g->drone.y, g->drone.x, g->drone.ch);

    wrefresh(s->win);
}

//------------------------------------------------------------------------MAIN

def main(){
	Screen screen;
    GameState state;

	initscr();			
	cbreak();			
	keypad(stdscr, TRUE);		
	curs_set(0);
	noecho();
	nodelay(stdscr, TRUE);

	srand((unsigned)time(NULL));
    init_screen(&screen);
    init_game(&state, &screen);

    int old_lines = LINES;
    int old_cols  = COLS;

	mvprintw(0, 0, "Press keys (w e r s d f x c v) to move, F2 to quit");
    refresh();
		
    // timer
    const int frame_us = 20 * 1000; // 20 ms => 50 Hz
    double dt = frame_us / 1e6;     

    int quit = 0;
    while (!quit) {
        int ch = getch();
        if (ch == KEY_F(2)) { 
            quit = 1; 
            continue;
        }

        input_move(&state, ch, &screen);
        update_move(&state, dt, &screen);
        render(&screen, &state);
        if (LINES != old_lines || COLS != old_cols) {
            old_lines = LINES;
            old_cols  = COLS;

            refresh_screen(&screen, &state);
        }

        usleep(frame_us);
    }


    destroy_win(screen.win);
	endwin();				  
	return 0;
}

#endif

quindi il file map divenderebbe cosi?
